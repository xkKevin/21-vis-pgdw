import groovy.text.SimpleTemplateEngine
import groovyx.net.http.FromServer
import groovyx.net.http.HttpBuilder

buildscript {
    repositories {
        maven { url("https://maven.aliyun.com/repository/public") }
        maven { url("https://maven.aliyun.com/repository/spring") }
        maven { url("https://maven.aliyun.com/repository/mapr-public") }
        maven { url("https://maven.aliyun.com/repository/spring-plugin") }
        maven { url("https://maven.aliyun.com/repository/gradle-plugin") }
        maven { url("https://maven.aliyun.com/repository/google") }
        maven { url("https://maven.aliyun.com/repository/jcenter") }
    }
}
plugins {
    id "de.undercouch.download" version "4.1.1"
    id "io.github.http-builder-ng.http-plugin" version "0.1.1"
}

def systemEnv = new HashMap<String, String>(System.getenv())
ext {
    mainVersion = "1.0.0"
    javaVersion = 1.8
    mavenRepositoryUrlList = [
            "https://maven.aliyun.com/repository/public",
            "https://maven.aliyun.com/repository/spring",
            "https://maven.aliyun.com/repository/mapr-public",
            "https://maven.aliyun.com/repository/spring-plugin",
            "https://maven.aliyun.com/repository/gradle-plugin",
            "https://maven.aliyun.com/repository/google",
            "https://maven.aliyun.com/repository/jcenter",
    ]
    gitCommitId = { ->
        def headDeafOutputStream = new ByteArrayOutputStream()
        exec {
            commandLine("git", "diff", "HEAD")
            standardOutput = headDeafOutputStream
        }
        def headDeaf = headDeafOutputStream.toString().trim()
        def clean = headDeaf.isEmpty()
        def commitIdOutputStream = new ByteArrayOutputStream()
        exec {
            commandLine("git", "rev-parse", "--short", "HEAD")
            standardOutput = commitIdOutputStream
        }
        return "${commitIdOutputStream.toString().trim()}${clean ? "" : ".dirty"}"
    }
    constructVersion = { ->
        return "${ext.mainVersion}-C${ext.gitCommitId()}"
    }
    render = { File templateFile, Map<String, String> dataMap, File targetFile ->
        println("templateFile(${templateFile.getAbsolutePath()}) -> targetFile(${targetFile.getAbsolutePath()})")
        project.file(targetFile).parentFile.mkdirs()
        project.file(targetFile).text = new SimpleTemplateEngine()
                .createTemplate(templateFile.text)
                .make(dataMap)
    }
    helmBinaryForCompilePath = "${project.buildDir}/runtime/bin/helm"
    // should depends on downloadHelmBinary
    pullHelmChartPackage = { File targetFile, String repo, String name, String version ->
        if (targetFile.exists()) {
            println("${targetFile} exists, skip pulling package")
            return
        }
        println("pulling ${name}:${version} from ${repo} to ${targetFile}")
        targetFile.parentFile.mkdirs()
        exec {
            workingDir(targetFile.parentFile.getAbsolutePath())
            executable(project.ext.helmBinaryForCompilePath)
            args(
                    "pull", name,
                    "--version", version,
                    "--repo", repo,
            )
        }
    }
    helmChart = [
            existsPackage: { String chartMuseumBaseUrl, String chartMuseumPrefixPath, String name, String version ->
                def http = HttpBuilder.configure {
                    request.uri = chartMuseumBaseUrl
                }
                http.get {
                    request.uri.path = "${chartMuseumPrefixPath}/api/charts/${name}/${version}"
                    response.success { FromServer fromServer, Object body ->
                        println("exists(${name}:${version}): ${responseBodyAsString(body)}")
                        return true
                    }
                    response.when(404) { FromServer fs, Object body ->
                        println("not exists(${name}:${version}): ${responseBodyAsString(body)}")
                        return false
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("query(${name}:${version}) failed: ${responseBodyAsString(body)}")
                    }
                }
            },
            deletePackage: { String chartMuseumBaseUrl, String chartMuseumPrefixPath, String name, String version ->
                def http = HttpBuilder.configure {
                    request.uri = chartMuseumBaseUrl
                }
                http.delete {
                    request.uri.path = "${chartMuseumPrefixPath}/api/charts/${name}/${version}"
                    response.success { FromServer fromServer, Object body ->
                        println("delete(${name}:${version}) succeed: ${responseBodyAsString(body)}")
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("delete(${name}:${version}) failed: ${responseBodyAsString(body)}")
                    }
                }
            },
            uploadPackage: {
                String chartMuseumBaseUrl,
                String chartMuseumPrefixPath,
                String name,
                String version,
                File packageFile ->
                    def http = HttpBuilder.configure {
                        request.uri = chartMuseumBaseUrl
                    }
                    http.post {
                        request.uri.path = "${chartMuseumPrefixPath}/api/charts"
                        request.contentType = "application/x-www-form-urlencoded"
                        request.body = project.file(packageFile)
                        response.success { FromServer fromServer, Object body ->
                            println("upload(${name}:${version}) succeed: ${responseBodyAsString(body)}")
                        }
                        response.failure { FromServer fromServer, Object body ->
                            throw new RuntimeException(
                                    "upload(${name}:${version}) failed: ${responseBodyAsString(body)}")
                        }
                    }
            },
    ]
    pushDockerImage = { List<String> imageNameWithTagList, String dockerRegistryService, String dockerExecutable ->
        imageNameWithTagList.each { imageNameWithTag ->
            println("pulling docker image: ${imageNameWithTag}")
            ExecResult inspectResult = exec {
                commandLine(dockerExecutable, "inspect", imageNameWithTag)
                ignoreExitValue(true)
            }
            if (0 == inspectResult.exitValue) {
                // exists
                println("image(${imageNameWithTag}) already exists, skip pulling image")
            } else {
                exec {
                    commandLine(dockerExecutable, "pull", imageNameWithTag)
                }
            }
            exec {
                commandLine(
                        dockerExecutable, "tag",
                        imageNameWithTag, "${dockerRegistryService}/${imageNameWithTag}"
                )
            }
            println("pushing docker image: ${imageNameWithTag} to ${dockerRegistryService}")
            exec {
                commandLine(
                        dockerExecutable, "push",
                        "${dockerRegistryService}/${imageNameWithTag}"
                )
            }
        }
    }
    software = [
            exists: { String flintBaseUrl, String name, String version ->
                def http = HttpBuilder.configure {
                    request.uri = flintBaseUrl
                }
                http.get {
                    request.uri.path = "/api/v1/software/${name}/${version}"
                    response.success { FromServer fromServer, Object body ->
                        if (body["success"]) {
                            return body["data"]["id"]
                        }
                        return null
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("query(${name}:${version}) failed: ${responseBodyAsString(body)}")
                    }
                }
            },
            // use update operation to do add
            update: { String flintBaseUrl, File softwareDefinitionFile ->
                def http = HttpBuilder.configure {
                    request.uri = flintBaseUrl
                }
                http.post {
                    request.uri.path = "/api/v1/software/"
                    request.contentType = "text/plain"
                    request.charset = "utf-8"
                    request.body = softwareDefinitionFile.text
                    response.success { FromServer fromServer, Object body ->
                        println("update software succeed: ${responseBodyAsString(body)}")
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("update software failed: ${responseBodyAsString(body)}")
                    }
                }
            },
    ]
    softwareInstance = [
            exists   : { String flintBaseUrl, String clusterName, String softwareInstanceName ->
                def http = HttpBuilder.configure {
                    request.uri = flintBaseUrl
                }
                http.get {
                    request.uri.path = "/api/v1/software/instance/findByName"
                    request.uri.query = [
                            clusterName : clusterName,
                            instanceName: softwareInstanceName,
                    ]
                    response.success { FromServer fromServer, Object body ->
                        if (body["success"]) {
                            return body["data"]["id"]
                        } else {
                            return null;
                        }
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException(
                                "query(${clusterName}:${softwareInstanceName}) failed: ${responseBodyAsString(body)}")
                    }
                }
            },
            install  : {
                String flintBaseUrl,
                String clusterName,
                String softwareInstanceName,
                String softwareName,
                String softwareVersion,
                File valuesYaml,
                String namespace ->
                    def http = HttpBuilder.configure {
                        request.uri = flintBaseUrl
                    }
                    http.put {
                        request.uri.path = "/api/v1/software/instance/"
                        request.contentType = "text/plain"
                        request.charset = "utf-8"
                        request.uri.query = [
                                clusterName    : clusterName,
                                softwareName   : softwareName,
                                softwareVersion: softwareVersion,
                                instanceName   : softwareInstanceName,
                                settingsYaml   : valuesYaml.text,
                                namespace      : namespace,

                        ]
                        response.success { FromServer fromServer, Object body ->
                            println("install softwareInstance(${clusterName}:${softwareInstanceName}) succeed: " +
                                    "${responseBodyAsString(body)}")
                        }
                        response.failure { FromServer fromServer, Object body ->
                            throw new RuntimeException("install softwareInstance(${clusterName}:${softwareInstanceName}) failed: " +
                                    "${responseBodyAsString(body)}")
                        }
                    }
            },
            uninstall: { String flintBaseUrl, String clusterName, Long softwareInstanceId ->
                def http = HttpBuilder.configure {
                    request.uri = flintBaseUrl
                }
                http.delete {
                    request.uri.path = "/api/v1/software/instance/"
                    request.uri.query = [
                            id: softwareInstanceId
                    ]
                    response.success { FromServer fromServer, Object body ->
                        println("uninstall softwareInstance(${softwareInstanceId}) succeed: " +
                                "${responseBodyAsString(body)}")
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("install softwareInstance(${softwareInstanceId}) failed: " +
                                "${responseBodyAsString(body)}")
                    }
                }
            },
            update   : {
                String flintBaseUrl,
                String clusterName,
                String softwareInstanceName,
                File valuesYaml ->
                    def http = HttpBuilder.configure {
                        request.uri = flintBaseUrl
                    }
                    http.post {
                        request.uri.path = "/api/v1/software/instance/"
                        request.contentType = "text/plain"
                        request.charset = "utf-8"
                        request.uri.query = [
                                clusterName : clusterName,
                                instanceName: softwareInstanceName,
                                settingsYaml: valuesYaml.text,
                        ]
                        response.success { FromServer fromServer, Object body ->
                            println("update softwareInstance(${clusterName}:${softwareInstanceName}) succeed: " +
                                    "${responseBodyAsString(body)}")
                        }
                        response.failure { FromServer fromServer, Object body ->
                            throw new RuntimeException("update softwareInstance(${clusterName}:${softwareInstanceName}) failed: " +
                                    "${responseBodyAsString(body)}")
                        }
                    }
            },
    ]
    kubernetes = [
            run: { String flintBaseUrl, String... arguments ->
                def http = HttpBuilder.configure {
                    request.uri = flintBaseUrl
                }
                http.post {
                    request.uri.path = "/api/v1/kubernetes/kubectl"
                    // TODO bugfix multi-values with same key
                    request.uri.query = ["argument": arguments.join(" ")]
                    response.success { FromServer fromServer, Object body ->
                        if (body["success"]) {
                            return body["data"]["std"]
                        } else {
                            throw new RuntimeException("run kubernetes command failed: ${body} ")
                        }
                    }
                    response.failure { FromServer fromServer, Object body ->
                        throw new RuntimeException("run kubernetes command failed: ${responseBodyAsString(body)}")
                    }
                }
            }
    ]
    localMode = Boolean.valueOf(systemEnv.get("localMode", "true"))
    environment = [
            chartMuseumBaseUrl   : systemEnv.get("chartMuseumBaseUrl", "http://master.k8s.local.geekcity.tech:32080"),
            chartMuseumPrefixPath: systemEnv.get("chartMuseumPrefixPath", "/chart/museum"),
            flintBaseUrl         : systemEnv.get("flintBaseUrl", "http://master.k8s.local.geekcity.tech:30080"),
            // may add
            // "insecure-registries": ["master.k8s.local.geekcity.tech:32500"]
            // to docker configuration json
            dockerRegistryService: systemEnv.get("dockerRegistryService", "master.k8s.local.geekcity.tech:32500"),
            clusterName          : systemEnv.get("clusterName", "core-cluster"),
            namespace            : systemEnv.get("namespace", "common-software"),
            hostSuffix           : systemEnv.get("hostSuffix", "local.geekcity.tech"),
            valuesFileName       : systemEnv.get("valuesFileName", "local.dev.values.yaml"),
            softwareInstanceNameSuffix: systemEnv.get("softwareInstanceNameSuffix", "-dev"),
    ]
    randomGenerator = { String alphabet, int n ->
        new Random().with { Random random ->
            (1..n).collect { alphabet[random.nextInt(alphabet.length())] }.join()
        }
    }
    appName = "somnus-app"
}
task downloadHelmBinary() {
    if (project.file(project.ext.helmBinaryForCompilePath).exists()) {
        println("skip ${name} as files exists")
        enabled(false)
    }
    doLast {
        def helmForCompilePackagePath = "${project.buildDir}/runtime/download/helm_for_compile.tar.gz"
        download {
            src constructHelmDownloadAddress()
            dest helmForCompilePackagePath
            tempAndMove true
            overwrite false
        }
        def helmForCompilePackageDirectory = project.file(helmForCompilePackagePath).parentFile.getAbsolutePath()
        def extractDirectoryPath = "${helmForCompilePackageDirectory}/helm_for_compile"
        project.file(extractDirectoryPath).mkdirs()
        exec {
            commandLine(
                    "tar",
                    "zxvf",
                    helmForCompilePackagePath,
                    "-C",
                    extractDirectoryPath,
            )
        }
        copy {
            from "${extractDirectoryPath}/${constructHelmPackageDirectoryName()}/helm"
            into project.file(project.ext.helmBinaryForCompilePath).parentFile.getAbsolutePath()
        }
        exec {
            commandLine(
                    "chmod",
                    "u+x",
                    project.ext.helmBinaryForCompilePath,
            )
        }
    }
}

private static String constructHelmDownloadAddress() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-darwin-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-darwin-amd64.tar.gz"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-linux-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-linux-amd64.tar.gz"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-darwin-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-darwin-amd64.tar.gz"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}

private static String constructHelmPackageDirectoryName() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        return "darwin-amd64"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        return "linux-amd64"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        return "darwin-amd64"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}

private static String responseBodyAsString(body) {
    body instanceof byte[] ? new String(body) : String.valueOf(body)
}