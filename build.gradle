import groovy.text.SimpleTemplateEngine
import org.gradle.internal.os.OperatingSystem

buildscript {
    repositories {
        maven { url("https://maven.aliyun.com/repository/public") }
        maven { url("https://maven.aliyun.com/repository/spring") }
        maven { url("https://maven.aliyun.com/repository/mapr-public") }
        maven { url("https://maven.aliyun.com/repository/spring-plugin") }
        maven { url("https://maven.aliyun.com/repository/gradle-plugin") }
        maven { url("https://maven.aliyun.com/repository/google") }
        maven { url("https://maven.aliyun.com/repository/jcenter") }
    }
}
plugins {
    id "de.undercouch.download" version "4.1.1"
    id "io.github.http-builder-ng.http-plugin" version "0.1.1"
}

String runtimeBinaryDirectory = "${project.buildDir}/runtime/bin"
HashMap<String, String> systemEnv = new HashMap<String, String>(System.getenv())
String localOperatingSystem = operatingSystem()
String localArch = arch()
ext {
    mavenRepositoryUrlList = [
            "https://maven.aliyun.com/repository/public",
            "https://maven.aliyun.com/repository/spring",
            "https://maven.aliyun.com/repository/mapr-public",
            "https://maven.aliyun.com/repository/spring-plugin",
            "https://maven.aliyun.com/repository/gradle-plugin",
            "https://maven.aliyun.com/repository/google",
            "https://maven.aliyun.com/repository/jcenter",
    ]
    os = localOperatingSystem
    arch = localArch
    mainVersion = "1.0.0"
    javaVersion = 1.8
    gitCommitId = { ->
        def headDeafOutputStream = new ByteArrayOutputStream()
        exec {
            commandLine("git", "diff", "HEAD")
            standardOutput = headDeafOutputStream
        }
        def headDeaf = headDeafOutputStream.toString().trim()
        def clean = headDeaf.isEmpty()

        def commitIdOutputStream = new ByteArrayOutputStream()
        exec {
            commandLine("git", "rev-parse", "--short", "HEAD")
            standardOutput = commitIdOutputStream
        }
        return "${commitIdOutputStream.toString().trim()}${clean ? "" : ".dirty"}"
    }
    constructVersion = { ->
        return "${ext.mainVersion}-C${ext.gitCommitId()}"
    }
    renderText = { File templateFile, Map<String, String> dataMap ->
        return doRenderText(templateFile, dataMap)
    }
    renderFile = { File templateFile, Map<String, String> dataMap, File targetFile ->
        doRenderFile(templateFile, dataMap, targetFile)
    }
    kubectlBaseUrl = systemEnv.getOrDefault("KUBECTL_BASE_URL", "https://dl.k8s.io/release")
    helmBaseUrl = systemEnv.getOrDefault("HELM_BASE_URL", "https://get.helm.sh")
    kubectlBinary = "${runtimeBinaryDirectory}/kubectl${ext.os == "windows" ? ".exe" : ""}"
    helmBinary = "${runtimeBinaryDirectory}/helm${ext.os == "windows" ? ".exe" : ""}"
    namespace = "somnus"
    softwareName = "somnus"
    imageBaseUrl = systemEnv.getOrDefault("IMAGE_BASE_URL", "https://resource.static.zjvis.net/docker-images/app")
    loadImageIfNotExists = { String imageIdentify, String imageUrl ->
        loadImageIfNotExists(imageIdentify, imageUrl)
    }
}

private String operatingSystem() {
    def current = OperatingSystem.current()
    if (current.isLinux()) {
        return "linux"
    }
    if (current.isMacOsX()) {
        return "darwin"
    }
    if (current.isWindows()) {
        return "windows"
    }
    throw new RuntimeException("not supported os: ${current}")
}

private String arch() {
    String arch = System.getProperty("os.arch")
    switch (arch) {
        case "x86":
            return "i386"
        case "x86_64":
            return "amd64"
        case "amd64":
        case "aarch64":
            return arch
        default:
            throw new RuntimeException("not supported arch: ${arch}")
    }
}

private void doRenderFile(File templateFile, Map<String, String> dataMap, File targetFile) {
    println("templateFile(${templateFile.getAbsolutePath()}) -> targetFile(${targetFile.getAbsolutePath()})")
    project.file(targetFile).parentFile.mkdirs()
    project.file(targetFile).text = doRenderText(templateFile, dataMap)
}

private String doRenderText(File templateFile, Map<String, String> dataMap) {
    println("templateFile(${templateFile.getAbsolutePath()})")
    return new SimpleTemplateEngine()
            .createTemplate(templateFile.text)
            .make(dataMap)
}

private void loadImageIfNotExists(String imageIdentify, String imageUrl) {
    if (imageExists(imageIdentify)) {
        println("skip loading image(${imageIdentify}) as image exists")
        return
    }
    File tempImageFile = File.createTempFile("docker.image.", ".dim")
    tempImageFile.delete()
    try {
        downloadImage(imageUrl, tempImageFile)
        loadImage(tempImageFile)
    } finally {
        if (tempImageFile.exists()) {
            tempImageFile.delete()
        }
    }
}

private void downloadImage(String url, File imageFile) {
    if (imageFile.exists()) {
        println("skip downloading ${imageFile.getAbsolutePath()} as file exists")
    } else {
        download {
            src url
            dest imageFile.getAbsolutePath()
            tempAndMove true
            overwrite false
        }
    }
}

private void loadImage(File imageFile) {
    exec {
        def execSpec = commandLine("docker", "image", "load", "-i", imageFile.getAbsolutePath())
        println("running command: ${String.join(" ", execSpec.getCommandLine())}")
    }
}

private boolean imageExists(String imageIdentify) {
    ExecResult inspectResult = exec {
        def execSpec = commandLine("docker", "image", "inspect", imageIdentify)
        println("running command: ${String.join(" ", execSpec.getCommandLine())}")
        ignoreExitValue(true)
    }
    return 0 == inspectResult.exitValue
}