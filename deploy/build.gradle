buildscript {
    repositories {
        for (mavenRepositoryUrl in project.rootProject.ext.mavenRepositoryUrlList) {
            maven { url(mavenRepositoryUrl) }
        }
    }
}
version = project.rootProject.ext.constructVersion()

def chartMuseumBaseUrl = project.rootProject.ext.environment.chartMuseumBaseUrl
def chartMuseumPrefixPath = project.rootProject.ext.environment.chartMuseumPrefixPath
def flintBaseUrl = project.rootProject.ext.environment.flintBaseUrl
def dockerRegistryService = project.rootProject.ext.environment.dockerRegistryService

def clusterName = project.rootProject.ext.environment.clusterName
def namespace = project.rootProject.ext.environment.namespace
def softwareInstanceNameSuffix = project.rootProject.ext.environment.softwareInstanceNameSuffix
def valuesFileName = project.rootProject.ext.environment.valuesFileName

def softwareName = project.rootProject.ext.appName
def softwareVersion = project.getVersion()
def helmPackagePath = "${project.buildDir}/runtime/download/${softwareName}-${softwareVersion}.tgz"
def softwareDefinitionTemplate = project.file("blackhole/software/software.yaml")
def softwareDefinitionPath = "${project.buildDir}/runtime/software/software.yaml"
def softwareInstanceName = "nebula-frontend${softwareInstanceNameSuffix}"
def valuesYamlTemplate = project.file("blackhole/software/${valuesFileName}")
def valuesYaml = project.file("${project.buildDir}/runtime/software/${valuesFileName}")
def imageNameWithTag = "${softwareName}:${softwareVersion}"

task renderChartYaml() {
    doLast {
        project.rootProject.ext.render(
                project.file("helm/Chart.template.yaml"),
                [
                        "doNotModifyComment": "# DO NOT modify, auto-generated by Chart.template.yaml",
                        "version"           : project.getVersion(),
                ],
                project.file("helm/Chart.yaml"),
        )
    }
}
task downloadHelmBinary() {
    if (project.file(project.rootProject.ext.helmBinaryForCompilePath).exists()) {
        println("skip ${name} as files exists")
        enabled(false)
    }
    doLast {
        def helmForCompilePackagePath = "${project.buildDir}/runtime/download/helm_for_compile.tar.gz"
        download {
            src constructHelmDownloadAddress()
            dest helmForCompilePackagePath
            tempAndMove true
            overwrite false
        }
        def helmForCompilePackageDirectory = project.file(helmForCompilePackagePath).parentFile.getAbsolutePath()
        def extractDirectoryPath = "${helmForCompilePackageDirectory}/helm_for_compile"
        project.file(extractDirectoryPath).mkdirs()
        exec {
            commandLine(
                    "tar",
                    "zxvf",
                    helmForCompilePackagePath,
                    "-C",
                    extractDirectoryPath,
            )
        }
        copy {
            from "${extractDirectoryPath}/${constructHelmPackageDirectoryName()}/helm"
            into project.file(project.rootProject.ext.helmBinaryForCompilePath).parentFile.getAbsolutePath()
        }
        exec {
            commandLine(
                    "chmod",
                    "u+x",
                    project.rootProject.ext.helmBinaryForCompilePath,
            )
        }
    }
}
task buildHelmPackage() {
    def runtimeHelmPackageDirectory = "${project.buildDir}/runtime/compile/"
    doFirst {
        project.file(runtimeHelmPackageDirectory).deleteDir()
        copy {
            from project.file("helm")
            into runtimeHelmPackageDirectory
        }
        project.file(helmPackagePath).parentFile.mkdirs()
    }
    doLast {
        exec {
            commandLine(
                    project.rootProject.ext.helmBinaryForCompilePath,
                    "dependency",
                    "build",
                    runtimeHelmPackageDirectory
            )
        }
        exec {
            workingDir(project.file(helmPackagePath).parentFile.getAbsolutePath())
            executable(project.rootProject.ext.helmBinaryForCompilePath)
            args(
                    "package",
                    runtimeHelmPackageDirectory
            )
        }
    }
    dependsOn(":downloadHelmBinary")
    dependsOn(renderChartYaml)
}

task uploadHelmPackage() {
    doFirst {
        if (project.rootProject.ext.helmChart.existsPackage(
                chartMuseumBaseUrl,
                chartMuseumPrefixPath,
                softwareName,
                softwareVersion,
        )) {
            project.rootProject.ext.helmChart.deletePackage(
                    chartMuseumBaseUrl,
                    chartMuseumPrefixPath,
                    softwareName,
                    softwareVersion,
            )
        }
    }
    doLast {
        println("uploading helm package(${softwareName}/${softwareVersion}) to chart museum...")
        project.rootProject.ext.helmChart.uploadPackage(
                chartMuseumBaseUrl,
                chartMuseumPrefixPath,
                softwareName,
                softwareVersion,
                project.file(helmPackagePath),
        )
    }
    dependsOn(buildHelmPackage)
}
task uploadDockerImage(type: Exec) {
    doFirst {
        exec {
            commandLine("docker", "tag", "${imageNameWithTag}", "${dockerRegistryService}/${imageNameWithTag}")
        }
        println("running command: ${String.join(" ", getCommandLine())}")
    }
    executable("docker")
    args(
            "push", "${dockerRegistryService}/${imageNameWithTag}",
    )
    dependsOn(":frontend:buildDockerImage")
    dependsOn(":backend:buildDockerImage")
    dependsOn(":morpheus:buildDockerImage")
}
task renderSoftwareDefinitionYaml() {
    doLast {
        project.rootProject.ext.render(
                softwareDefinitionTemplate,
                [
                        "chartMuseumService": "${chartMuseumBaseUrl}${chartMuseumPrefixPath}",
                        "name"              : softwareName,
                        "version"           : softwareVersion,
                ],
                project.file(softwareDefinitionPath))
    }
}
task addSoftware() {
    doLast {
        def softwareId = project.rootProject.ext.software.exists(
                flintBaseUrl,
                softwareName,
                softwareVersion,
        )
        if (null == softwareId) {
            println("software not exists, add it")
            project.rootProject.ext.software.update(
                    flintBaseUrl,
                    project.file(softwareDefinitionPath)
            )
        } else {
            println("software already exists(id=${softwareId}), update it")
            project.rootProject.ext.software.update(
                    flintBaseUrl,
                    project.file(softwareDefinitionPath)
            )
        }
    }
    dependsOn(uploadHelmPackage)
    dependsOn(uploadDockerImage)
    dependsOn(renderSoftwareDefinitionYaml)
}
task installSoftware() {
    doFirst {
        project.rootProject.ext.render(
                valuesYamlTemplate,
                [
                        name           : softwareName,
                        version        : softwareVersion,
                        deployTimestamp: System.currentTimeMillis(),
                ],
                valuesYaml,
        )
    }
    doLast {
        def softwareInstanceId = project.rootProject.ext.softwareInstance.exists(
                flintBaseUrl,
                clusterName,
                softwareInstanceName,
        )
        if (null != softwareInstanceId) {
            println("softwareInstance(${clusterName}:${softwareInstanceName}) exists(id=${softwareInstanceId}), " +
                    "uninstalling it...")
            project.rootProject.ext.softwareInstance.uninstall(
                    flintBaseUrl, clusterName, softwareInstanceId)
        }
        project.rootProject.ext.softwareInstance.install(
                flintBaseUrl,
                clusterName, softwareInstanceName,
                softwareName, softwareVersion,
                valuesYaml,
                namespace,
        )
    }
    dependsOn(addSoftware)
}
task updateSoftwareInstance() {
    doFirst {
        project.rootProject.ext.render(
                valuesYamlTemplate,
                [
                        name           : softwareName,
                        version        : softwareVersion,
                        deployTimestamp: System.currentTimeMillis(),
                ],
                valuesYaml,
        )
    }
    doFirst {
        def softwareInstanceId = project.rootProject.ext.softwareInstance.exists(
                flintBaseUrl,
                clusterName,
                softwareInstanceName,
        )
        if (null == softwareInstanceId) {
            throw new RuntimeException("softwareInstance(${clusterName}:${softwareInstanceName}) not found")
        }
    }
    doLast {
        project.rootProject.ext.softwareInstance.update(
                flintBaseUrl,
                clusterName,
                softwareInstanceName,
                valuesYaml,
        )
    }
    dependsOn(addSoftware)
}
task uninstallSoftware() {
    def softwareInstanceId
    doFirst {
        softwareInstanceId = project.rootProject.ext.softwareInstance.exists(
                flintBaseUrl,
                clusterName,
                softwareInstanceName,
        )
        if (null == softwareInstanceId) {
            throw new RuntimeException("softwareInstance(${clusterName}:${softwareInstanceName}) not found")
        }
    }
    doLast {
        project.rootProject.ext.softwareInstance.uninstall(
                flintBaseUrl, clusterName, softwareInstanceId
        )
    }
}

private static String constructHelmDownloadAddress() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-darwin-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-darwin-amd64.tar.gz"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-linux-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-linux-amd64.tar.gz"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        // mirror of https://get.helm.sh/helm-v3.6.0-darwin-amd64.tar.gz
        return "http://proxy.geekcity.tech:30080/helm-v3.6.0-darwin-amd64.tar.gz"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}

private static String constructHelmPackageDirectoryName() {
    def operatingSystem = org.gradle.internal.os.OperatingSystem.current();
    def arch = System.getProperty("os.arch")
    if (operatingSystem.isMacOsX() && "x86_64" == arch) {
        return "darwin-amd64"
    }
    if (operatingSystem.isLinux() && "amd64" == arch) {
        return "linux-amd64"
    }
    // not fully tested
    if (operatingSystem.isMacOsX() && "aarch64" == arch) {
        return "darwin-amd64"
    }
    throw new RuntimeException("not supported operating system(${operatingSystem.getName()}) or arch(${arch})")
}

private static String responseBodyAsString(body) {
    body instanceof byte[] ? new String(body) : String.valueOf(body)
}
